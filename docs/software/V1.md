# Software V1

Pour réaliser l'ensemble de nos tests nous avons mis en place un broker MQTT à l'adresse 178.170.38.88 et le port 55555.

## Fonctionnalités prises en compte.

### Connexion wifi:

Pour pouvoir reçevoir les commandes via MQTT , la esp32c3 doit pouvoir se connecter à un réseau wifi stable.  
Les fonctionnalités wifi de la carte sont disponible via la librairie **WiFi.h**, elle permet de scanner les wifis des alentours et de s'y connecter si besoin.  
Les fonctions ScanWifi et connectToWifi permettent de scanner les wifis environnant et de s'y connecter en renseignant le SSID et le mot de passe au préalable. Dans la version actuelle, le ssid et le mot de passe sont rentrés en dur au début du programme (à changer dans une version future).
A savoir que le programme ne démarre pas si une connexion wifi n'est pas établie et si celle ci n'est pas assez puissante.

### Connexion au broker MQTT:

La réception des commandes du bracelet se faisant par MQTT , une connexion continue et robuste est nécessaire. La bibliothèque PubSubClient.h nous donne tous les outils nécessaire.  
Plusieurs fonctions sont responsable de la gestion du MQTT :  

- connectToBroker : Cette fonction se connecte au serveur via la méthode setServer et en paramètre l'ip du broker et le port de communication. La connexion au broker doit durée pendant tout le vol il est donc important de prioriser les reconnexions au broker en cas de déconnexion. Ce code tente de se reconnecter au broker en cas de déconnexion.  
Cette fonction est aussi responsable de l'abonnement aux topics via la méthode subscrire(topic).

- Callback : C'est la fonction qui est appelé lors de la réception d'un message. Cette fonction prend 3 paramètres : char *topic, byte *payload, unsigned int length.  Le topic sur lequel le message a été réceptionné , le payload c'est à dire le message réceptionné en lui même et la taille du message.  
L'idée de cette fonction est d'exécuter les commandes reçues via MQTT sur les différents topics possible en analysant le message et exécutant l'ordre.  
Dans l'état actuel , la fonction callback reçoit un premier message de configuration sur le topic /config/ qui permet de configurer les patterns vibratoires à jouer en fonction du message reçu. Elle le déparse avec Json et attribue le pattern à l'alerte.  
Puis l'ensemble des réceptions se font sur le topic pattern qui s'occupe d'envoyer les commandes au bracelet.  
Exemple de message:  
Config : mosquitto_pub -h 178.170.38.88 -t /config/ -m '{"alert":"2,56,2,56"}' -p 55555 , ici on donne le pattern du dessus au message alert.  
Pattern : mosquitto_pub -h 178.170.38.88 -t /pattern/ -m alert -p 55555.  
Ici le bracelet reçoit la commande alert et va donc exécuter le pattern alert définit via la commande config du dessus.  
Cette fonctionnalité rend la configuration des patterns totalement modulable et dynamique.  

### Scan I2C + Contrôle DRV2605/Moteur et TCA9548A

L'ensemble des composants du bracelet communiquant via I2C, il est nécessaire de gérer cette partie dans le code.  
Le problème majeur de ce système est l'adresse fixe des drivers haptique DRV2605l qui se partagent tous l'adresse Ox5A.  
C'est la que le TCA rentre en jeu il mappe chacun de ces 8 canaux à un driver différent.  
La fonction **initMult** du code utilise la bibliothèque "TCA9548.h"
 pour pouvoir utiliser chaque moteur indépendamment. Premièrement elle démarre une transmission très brève avec ces 2 lignes : Wire.beginTransmission(0x70);  
  byte error = Wire.endTransmission(); et vérifie le statut de la réponse pour voir si le TCA est reconnu. 0x70 correspond à l'adresse du TCA.  
Si le status est bon , le code parcourt les 8 canaux du TCA pour trouver l'adresse I2C des Drivers et compter le nombre de drivers actifs s'ils sont trouvés. C'est utile pour savoir si un driver ou moteur est HS.  
L'idée finale de cette fonction est de pouvoir utiliser un DRV2605l indépendamment même avec leurs adresses fixes via la méthode MP.selectChannel(x) ou x correspond au channel du TCA.

- Contôle des moteurs:   
Une fois le TCA configuré et les drivers détectés, il est possible de piloter les moteurs via la librairie du DRV2605l --> "Adafruit_DRV2605.h".  
L'avantage du driver et de cette librairie est qu'elle propose une panoplie de pattern déja configuré.  
Reprenons l'exemple de la configuration, nous avons configuré alert avec 2,56,2,56.  
La librairie contient 123 patterns différents et chaque nombre de cette liste contient un pattern spécifique.  
 Actuellement nous avons identifié quelques pattern intéressant tel que le 118 : " Long buzz for programattic stopping 100%" , le 56 : " Pulsing shark 100%" et le 16 : "1000ms alert 100%".
En monocoeur il est impossible de faire vibrer plusieurs moteurs en même temps et c'est pourquoi que la configuration se fait suivant cette logique.  
{"alert":"2,56,2,56"} signifie donc joué la séquence 56 sur le moteur 2 à l'instant t0 et joué la séquence 56 sur le moteur 2 à l'instant t1.  Ainsi les séquences sont facilement modulable, une configuration finale si le bracelet contient 8 moteurs par exemple pourrait être:  
{"alert":"0,118,1,118,2,118,3,118,4,118,5,118,6,118,7,118} ainsi chaque moteur jouera la séquence 118 avec une illusion de simultanéité.  
La durée entre 2 séquences devra être défini dans un futur proche ainsi que le nombre de répétitions car une telle configuration ne fera vibrer les moteurs qu'une fois.

### Idée de topic: 
L'adresse mac de la carte peut se trouver via la méthode WiFi.mac_adress() rendant chaque carte et chaque bracelet facilement identifiable et de manière unique. Ainsi, pour limiter la communication avec un seul bracelet spécifique, les communications via topic peuvent commencer par /adresse_mac_esp32/...

### Mise en place de protocole de sécurité:
La puce de l'esp32c3 contient un capteur de température intégré qui permet de contrôler la température en temps réel. Une température trop élevée peut ainsi être détecté le plus tôt possible pour éviter tout incident pendant le vol. La priorité absolue de ce code est la reconnexion au broker MQTT en cas de déconnexion et une mise en place d'un protocole + robuste sera à prévoir.  

### Point à approdondir:
Mise en place de système de patterns plus robuste et plus efficace prenant en compte le délai entre chaques séquences , actuellement un délai prédéfini et mis en place.  Définir des règles de priorité plus efficace en ce qui concerne la reconnexion au broker et au wifi via des bibliothèques d'ordonnancement tel que freeRTOS.h.  
Un script de détection des anomalies devra être mis en place.  
Puis une gestion plus fine des topics sera nécessaire.


   
